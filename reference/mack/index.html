<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Index - Mack</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Index";
        var mkdocs_page_input_path = "reference/mack/index.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Mack
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Mack</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../SUMMARY/">API Docs</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Mack</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Index</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div class="doc doc-object doc-module">


<a id="mack"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h2 id="mack.append_without_duplicates" class="doc doc-heading">
<code class="highlight language-python">append_without_duplicates(delta_table, append_df, p_keys)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>append_df</code></td>
          <td>
                <code><span title="pyspark.sql.dataframe.DataFrame">DataFrame</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>p_keys</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def append_without_duplicates(
    delta_table: DeltaTable, append_df: DataFrame, p_keys: List[str]
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param append_df: &lt;description&gt;
    :type append_df: DataFrame
    :param p_keys: &lt;description&gt;
    :type p_keys: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type.
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    condition_columns = []
    for column in p_keys:
        condition_columns.append(f"old.{column} = new.{column}")

    condition_columns = " AND ".join(condition_columns)

    deduplicated_append_df = append_df.drop_duplicates(p_keys)

    # Insert records without duplicates
    delta_table.alias("old").merge(
        deduplicated_append_df.alias("new"), condition_columns
    ).whenNotMatchedInsertAll().execute()</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.constraint_append" class="doc doc-heading">
<code class="highlight language-python">constraint_append(delta_table, append_df, quarantine_table)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>append_df</code></td>
          <td>
                <code><span title="pyspark.sql.dataframe.DataFrame">DataFrame</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>quarantine_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have an invalid type.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when delta_table has no constraints.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def constraint_append(
    delta_table: DeltaTable, append_df: DataFrame, quarantine_table: DeltaTable
):
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param append_df: &lt;description&gt;
    :type append_df: DataFrame
    :param quarantine_table: &lt;description&gt;
    :type quarantine_table: DeltaTable

    :raises TypeError: Raises type error when input arguments have an invalid type.
    :raises TypeError: Raises type error when delta_table has no constraints.
    """

    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified for delta_table.")

    if not isinstance(append_df, DataFrame):
        raise TypeError("You must provide a DataFrame that is to be appended.")

    if quarantine_table is not None and not isinstance(quarantine_table, DeltaTable):
        raise TypeError(
            "An existing delta table must be specified for quarantine_table."
        )

    properties = delta_table.detail().select("properties").collect()[0]["properties"]
    check_constraints = [
        v for k, v in properties.items() if k.startswith("delta.constraints")
    ]

    # add null checks
    fields = delta_table.toDF().schema.fields
    null_constraints = [
        f"{field.name} is not null" for field in fields if not field.nullable
    ]

    constraints = check_constraints + null_constraints

    if not constraints:
        raise TypeError("There are no constraints present in the target delta table")

    target_details = delta_table.detail().select("location").collect()[0]
    if quarantine_table:
        quarantine_details = quarantine_table.detail().select("location").collect()[0]
        quarantine_df = append_df.filter(
            "not (" + " and ".join([c for c in constraints]) + ")"
        )
        (
            quarantine_df.write.format("delta")
            .mode("append")
            .option("mergeSchema", "true")
            .save(quarantine_details["location"])
        )

    filtered_df = append_df.filter(" and ".join([c for c in constraints]))
    (
        filtered_df.write.format("delta")
        .mode("append")
        .option("mergeSchema", "true")
        .save(target_details["location"])
    )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.copy_table" class="doc doc-heading">
<code class="highlight language-python">copy_table(delta_table, target_path='', target_table='')</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>target_path</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description>, defaults to empty string.</p></td>
          <td>
                <code>&#39;&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>target_table</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description>, defaults to empty string.</p></td>
          <td>
                <code>&#39;&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type, are missing or are empty.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def copy_table(
    delta_table: DeltaTable, target_path: str = "", target_table: str = ""
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param target_path: &lt;description&gt;, defaults to empty string.
    :type target_path: str
    :param target_table: &lt;description&gt;, defaults to empty string.
    :type target_table: str

    :raises TypeError: Raises type error when input arguments have a invalid type, are missing or are empty.
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not target_path and not target_table:
        raise TypeError("Either target_path or target_table must be specified.")

    origin_table = delta_table.toDF()

    details = delta_table.detail().select("partitionColumns", "properties").collect()[0]

    if target_table:
        (
            origin_table.write.format("delta")
            .partitionBy(details["partitionColumns"])
            .options(**details["properties"])
            .saveAsTable(target_table)
        )
    else:
        (
            origin_table.write.format("delta")
            .partitionBy(details["partitionColumns"])
            .options(**details["properties"])
            .save(target_path)
        )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.delta_file_sizes" class="doc doc-heading">
<code class="highlight language-python">delta_file_sizes(delta_table)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>Dict[str, int]</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def delta_file_sizes(delta_table: DeltaTable) -&gt; Dict[str, int]:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable

    :returns: &lt;description&gt;
    :rtype: Dict[str, int]
    """
    details = delta_table.detail().select("numFiles", "sizeInBytes").collect()[0]
    size_in_bytes, number_of_files = details["sizeInBytes"], details["numFiles"]
    average_file_size_in_bytes = round(size_in_bytes / number_of_files, 0)

    return {
        "size_in_bytes": size_in_bytes,
        "number_of_files": number_of_files,
        "average_file_size_in_bytes": average_file_size_in_bytes,
    }</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.drop_duplicates" class="doc doc-heading">
<code class="highlight language-python">drop_duplicates(delta_table, duplication_columns)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>duplication_columns</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type, are missing or are empty.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def drop_duplicates(delta_table: DeltaTable, duplication_columns: List[str]) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param duplication_columns: &lt;description&gt;
    :type duplication_columns: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type, are missing or are empty.
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not duplication_columns or len(duplication_columns) == 0:
        raise TypeError("A duplication column must be specified.")

    data_frame = delta_table.toDF()

    details = delta_table.detail().select("location").collect()[0]

    (
        data_frame.drop_duplicates(duplication_columns)
        .write.format("delta")
        .mode("overwrite")
        .save(details["location"])
    )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.drop_duplicates_pkey" class="doc doc-heading">
<code class="highlight language-python">drop_duplicates_pkey(delta_table, primary_key, duplication_columns)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>primary_key</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>duplication_columns</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type, are missing or are empty.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required columns are missing in the provided delta table.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def drop_duplicates_pkey(
    delta_table: DeltaTable, primary_key: str, duplication_columns: List[str]
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param primary_key: &lt;description&gt;
    :type primary_key: str
    :param duplication_columns: &lt;description&gt;
    :type duplication_columns: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type, are missing or are empty.
    :raises TypeError: Raises type error when required columns are missing in the provided delta table.
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not primary_key:
        raise TypeError("A unique primary key must be specified.")

    if not duplication_columns or len(duplication_columns) == 0:
        raise TypeError("A duplication column must be specified.")

    if primary_key in duplication_columns:
        raise TypeError("Primary key must not be part of the duplication columns.")

    data_frame = delta_table.toDF()

    # Make sure that all the required columns are present in the provided delta table
    append_data_columns = data_frame.columns
    required_columns = [primary_key] + duplication_columns
    for required_column in required_columns:
        if required_column not in append_data_columns:
            raise TypeError(
                f"The base table has these columns {append_data_columns!r}, but these columns are required {required_columns!r}"
            )

    q = []

    duplicate_records = (
        data_frame.withColumn(
            "row_number",
            row_number().over(
                Window().partitionBy(duplication_columns).orderBy(primary_key)
            ),
        )
        .filter(col("row_number") &gt; 1)
        .drop("row_number")
        .distinct()
    )
    for column in required_columns:
        q.append(f"old.{column} = new.{column}")

    q = " AND ".join(q)

    # Remove all the duplicate records
    delta_table.alias("old").merge(
        duplicate_records.alias("new"), q
    ).whenMatchedDelete().execute()</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.find_composite_key_candidates" class="doc doc-heading">
<code class="highlight language-python">find_composite_key_candidates(df, exclude_cols=None)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>df</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[<span title="delta.DeltaTable">DeltaTable</span>, <span title="pyspark.sql.dataframe.DataFrame">DataFrame</span>]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>exclude_cols</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>List</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when no composite key can be found.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def find_composite_key_candidates(
    df: Union[DeltaTable, DataFrame], exclude_cols: List[str] = None
) -&gt; List:
    """
    &lt;description&gt;

    :param df: &lt;description&gt;
    :type df: DeltaTable or DataFrame
    :param exclude_cols: &lt;description&gt;
    :type exclude_cols: List[str], defaults to None.

    :raises TypeError: Raises type error when no composite key can be found.

    :returns: &lt;description&gt;
    :rtype: List
    """
    if type(df) == DeltaTable:
        df = df.toDF()
    if exclude_cols is None:
        exclude_cols = []
    df_col_excluded = df.drop(*exclude_cols)
    total_cols = len(df_col_excluded.columns)
    total_row_count = df_col_excluded.distinct().count()
    for n in range(1, len(df_col_excluded.columns) + 1):
        for c in combinations(df_col_excluded.columns, n):
            if df_col_excluded.select(*c).distinct().count() == total_row_count:
                if len(df_col_excluded.select(*c).columns) == total_cols:
                    raise ValueError("No composite key candidates could be identified.")
                return list(df_col_excluded.select(*c).columns)</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.humanize_bytes" class="doc doc-heading">
<code class="highlight language-python">humanize_bytes(n)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>n</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def humanize_bytes(n: int) -&gt; str:
    """
    &lt;description&gt;

    :param n: &lt;description&gt;
    :type n: int

    :returns: &lt;description&gt;
    :rtype: str
    """
    kilobyte = 1000
    for prefix, k in (
        ("PB", kilobyte**5),
        ("TB", kilobyte**4),
        ("GB", kilobyte**3),
        ("MB", kilobyte**2),
        ("kB", kilobyte**1),
    ):
        if n &gt;= k * 0.9:
            return f"{n / k:.2f} {prefix}"
    return f"{n} B"</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.humanize_bytes_binary" class="doc doc-heading">
<code class="highlight language-python">humanize_bytes_binary(n)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>n</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def humanize_bytes_binary(n: int) -&gt; str:
    """
    &lt;description&gt;

    :param n: &lt;description&gt;
    :type n: int

    :returns: &lt;description&gt;
    :rtype: str
    """
    kibibyte = 1024
    for prefix, k in (
        ("PB", kibibyte**5),
        ("TB", kibibyte**4),
        ("GB", kibibyte**3),
        ("MB", kibibyte**2),
        ("kB", kibibyte**1),
    ):
        if n &gt;= k * 0.9:
            return f"{n / k:.2f} {prefix}"
    return f"{n} B"</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.is_composite_key_candidate" class="doc doc-heading">
<code class="highlight language-python">is_composite_key_candidate(delta_table, cols)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>cols</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>bool</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type or are missing.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required columns are not in dataframe columns.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def is_composite_key_candidate(delta_table: DeltaTable, cols: List[str]) -&gt; bool:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param cols: &lt;description&gt;
    :type cols: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type or are missing.
    :raises TypeError: Raises type error when required columns are not in dataframe columns.

    :returns: &lt;description&gt;
    :rtype: bool
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not cols or len(cols) == 0:
        raise TypeError("At least one column must be specified.")

    data_frame = delta_table.toDF()

    for required_column in cols:
        if required_column not in data_frame.columns:
            raise TypeError(
                f"The base table has these columns {data_frame.columns!r}, but these columns are required {cols!r}"
            )

    duplicate_records = (
        data_frame.withColumn(
            "amount_of_records",
            count("*").over(Window.partitionBy(cols)),
        )
        .filter(col("amount_of_records") &gt; 1)
        .drop("amount_of_records")
    )

    if len(duplicate_records.take(1)) == 0:
        return True

    return False</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.kill_duplicates" class="doc doc-heading">
<code class="highlight language-python">kill_duplicates(delta_table, duplication_columns)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>duplication_columns</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type or are empty.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required columns are missing in the provided delta table.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def kill_duplicates(delta_table: DeltaTable, duplication_columns: List[str]) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param duplication_columns: &lt;description&gt;
    :type duplication_columns: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type or are empty.
    :raises TypeError: Raises type error when required columns are missing in the provided delta table.
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not duplication_columns or len(duplication_columns) == 0:
        raise TypeError("Duplication columns must be specified")

    data_frame = delta_table.toDF()

    # Make sure that all the required columns are present in the provided delta table
    append_data_columns = data_frame.columns
    for required_column in duplication_columns:
        if required_column not in append_data_columns:
            raise TypeError(
                f"The base table has these columns {append_data_columns!r}, but these columns are required {duplication_columns!r}"
            )

    q = []

    duplicate_records = (
        data_frame.withColumn(
            "amount_of_records",
            count("*").over(Window.partitionBy(duplication_columns)),
        )
        .filter(col("amount_of_records") &gt; 1)
        .drop("amount_of_records")
        .distinct()
    )

    for column in duplication_columns:
        q.append(f"old.{column} = new.{column}")

    q = " AND ".join(q)

    # Remove all the duplicate records
    delta_table.alias("old").merge(
        duplicate_records.alias("new"), q
    ).whenMatchedDelete().execute()</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.latest_version" class="doc doc-heading">
<code class="highlight language-python">latest_version(delta_table)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def latest_version(delta_table: DeltaTable) -&gt; float:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable

    :returns: &lt;description&gt;
    :rtype: float
    """
    version = delta_table.history().agg(max("version")).collect()[0][0]
    return version</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.rename_delta_table" class="doc doc-heading">
<code class="highlight language-python">rename_delta_table(delta_table, new_table_name, table_location=None, databricks=False, spark_session=None)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Renames a Delta table to a new name. This function can be used in a Databricks environment or with a
standalone Spark session.</p>
<p>Parameters:
delta_table (DeltaTable): The DeltaTable object representing the table to be renamed.
new_table_name (str): The new name for the table.
table_location (str, optional): The file path where the table is stored. Defaults to None.
    If None, the function will attempt to determine the location from the DeltaTable object.
databricks (bool, optional): A flag indicating whether the function is being run in a Databricks
    environment. Defaults to False. If True, a SparkSession must be provided.
spark_session (pyspark.sql.SparkSession, optional): The Spark session. Defaults to None.
    Required if <code>databricks</code> is set to True.</p>
<p>Returns:
None</p>
<p>Raises:
TypeError: If the provided <code>delta_table</code> is not a DeltaTable object, or if <code>databricks</code> is True
    and <code>spark_session</code> is None.</p>
<p>Example Usage:</p>
<blockquote>
<blockquote>
<blockquote>
<p>rename_delta_table(existing_delta_table, "new_table_name")</p>
</blockquote>
</blockquote>
</blockquote>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def rename_delta_table(
    delta_table: DeltaTable,
    new_table_name: str,
    table_location: str = None,
    databricks: bool = False,
    spark_session: pyspark.sql.SparkSession = None,
) -&gt; None:
    """
    Renames a Delta table to a new name. This function can be used in a Databricks environment or with a
    standalone Spark session.

    Parameters:
    delta_table (DeltaTable): The DeltaTable object representing the table to be renamed.
    new_table_name (str): The new name for the table.
    table_location (str, optional): The file path where the table is stored. Defaults to None.
        If None, the function will attempt to determine the location from the DeltaTable object.
    databricks (bool, optional): A flag indicating whether the function is being run in a Databricks
        environment. Defaults to False. If True, a SparkSession must be provided.
    spark_session (pyspark.sql.SparkSession, optional): The Spark session. Defaults to None.
        Required if `databricks` is set to True.

    Returns:
    None

    Raises:
    TypeError: If the provided `delta_table` is not a DeltaTable object, or if `databricks` is True
        and `spark_session` is None.

    Example Usage:
    &gt;&gt;&gt; rename_delta_table(existing_delta_table, "new_table_name")
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified for delta_table.")
    if databricks and spark_session is None:
        raise TypeError("A spark session must be specified for databricks.")

    if databricks:
        spark_session.sql(f"ALTER TABLE {delta_table.name} RENAME TO {new_table_name}")
    else:
        delta_table.toDF().write.format("delta").mode("overwrite").saveAsTable(
            new_table_name
        )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.show_delta_file_sizes" class="doc doc-heading">
<code class="highlight language-python">show_delta_file_sizes(delta_table, humanize_binary=False)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>humanize_binary</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p><description></p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>None</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def show_delta_file_sizes(
    delta_table: DeltaTable, humanize_binary: bool = False
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param humanize_binary: &lt;description&gt;
    :type humanize_binary: bool

    :returns: &lt;description&gt;
    :rtype: None
    """
    details = delta_table.detail().select("numFiles", "sizeInBytes").collect()[0]
    size_in_bytes, number_of_files = details["sizeInBytes"], details["numFiles"]
    average_file_size_in_bytes = round(size_in_bytes / number_of_files, 0)

    if humanize_binary:
        humanized_size_in_bytes = humanize_bytes_binary(size_in_bytes)
        humanized_average_file_size = humanize_bytes_binary(average_file_size_in_bytes)
    else:
        humanized_size_in_bytes = humanize_bytes(size_in_bytes)
        humanized_average_file_size = humanize_bytes(average_file_size_in_bytes)
    humanized_number_of_files = f"{number_of_files:,}"

    print(
        f"The delta table contains {humanized_number_of_files} files with a size of {humanized_size_in_bytes}."
        + f" The average file size is {humanized_average_file_size}"
    )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.type_2_scd_generic_upsert" class="doc doc-heading">
<code class="highlight language-python">type_2_scd_generic_upsert(delta_table, updates_df, primary_key, attr_col_names, is_current_col_name, effective_time_col_name, end_time_col_name)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p>DeltaTable</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>updates_df</code></td>
          <td>
                <code><span title="pyspark.sql.dataframe.DataFrame">DataFrame</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>primary_key</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>attr_col_names</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>is_current_col_name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>effective_time_col_name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>end_time_col_name</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>None</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required column names are not in the base table.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required column names for updates are not in the attributes columns list.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def type_2_scd_generic_upsert(
    delta_table: DeltaTable,
    updates_df: DataFrame,
    primary_key: str,
    attr_col_names: List[str],
    is_current_col_name: str,
    effective_time_col_name: str,
    end_time_col_name: str,
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: DeltaTable
    :type path: str
    :param updates_df: &lt;description&gt;
    :type updates_df: DataFrame
    :param primary_key: &lt;description&gt;
    :type primary_key: str
    :param attr_col_names: &lt;description&gt;
    :type attr_col_names: List[str]
    :param is_current_col_name: &lt;description&gt;
    :type is_current_col_name: str
    :param effective_time_col_name: &lt;description&gt;
    :type effective_time_col_name: str
    :param end_time_col_name: &lt;description&gt;
    :type effective_time_col_name: str

    :raises TypeError: Raises type error when required column names are not in the base table.
    :raises TypeError: Raises type error when required column names for updates are not in the attributes columns list.

    :returns: &lt;description&gt;
    :rtype: None
    """

    # validate the existing Delta table
    base_col_names = delta_table.toDF().columns
    required_base_col_names = (
        [primary_key]
        + attr_col_names
        + [is_current_col_name, effective_time_col_name, end_time_col_name]
    )
    if sorted(base_col_names) != sorted(required_base_col_names):
        raise TypeError(
            f"The base table has these columns {base_col_names!r}, but these columns are required {required_base_col_names!r}"
        )
    # validate the updates DataFrame
    updates_col_names = updates_df.columns
    required_updates_col_names = (
        [primary_key] + attr_col_names + [effective_time_col_name]
    )
    if sorted(updates_col_names) != sorted(required_updates_col_names):
        raise TypeError(
            f"The updates DataFrame has these columns {updates_col_names!r}, but these columns are required {required_updates_col_names!r}"
        )

    # perform the upsert
    updates_attrs = list(
        map(lambda attr: f"updates.{attr} &lt;&gt; base.{attr}", attr_col_names)
    )
    updates_attrs = " OR ".join(updates_attrs)
    staged_updates_attrs = list(
        map(lambda attr: f"staged_updates.{attr} &lt;&gt; base.{attr}", attr_col_names)
    )
    staged_updates_attrs = " OR ".join(staged_updates_attrs)
    staged_part_1 = (
        updates_df.alias("updates")
        .join(delta_table.toDF().alias("base"), primary_key)
        .where(f"base.{is_current_col_name} = true AND ({updates_attrs})")
        .selectExpr("NULL as mergeKey", "updates.*")
    )
    staged_part_2 = updates_df.selectExpr(f"{primary_key} as mergeKey", "*")
    staged_updates = staged_part_1.union(staged_part_2)
    thing = {}
    for attr in attr_col_names:
        thing[attr] = f"staged_updates.{attr}"
    thing2 = {
        primary_key: f"staged_updates.{primary_key}",
        is_current_col_name: "true",
        effective_time_col_name: f"staged_updates.{effective_time_col_name}",
        end_time_col_name: "null",
    }
    res_thing = {**thing, **thing2}
    res = (
        delta_table.alias("base")
        .merge(
            source=staged_updates.alias("staged_updates"),
            condition=pyspark.sql.functions.expr(f"base.{primary_key} = mergeKey"),
        )
        .whenMatchedUpdate(
            condition=f"base.{is_current_col_name} = true AND ({staged_updates_attrs})",
            set={
                is_current_col_name: "false",
                end_time_col_name: f"staged_updates.{effective_time_col_name}",
            },
        )
        .whenNotMatchedInsert(values=res_thing)
        .execute()
    )
    return res</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.type_2_scd_upsert" class="doc doc-heading">
<code class="highlight language-python">type_2_scd_upsert(delta_table, updates_df, primary_key, attr_col_names)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>path</code></td>
          <td>
                <code>DeltaTable</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>updates_df</code></td>
          <td>
                <code><span title="pyspark.sql.dataframe.DataFrame">DataFrame</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>primary_key</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>attr_col_names</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>None</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def type_2_scd_upsert(
    delta_table: DeltaTable,
    updates_df: DataFrame,
    primary_key: str,
    attr_col_names: List[str],
) -&gt; None:
    """
    &lt;description&gt;

    :param path: &lt;description&gt;
    :type path: DeltaTable
    :param updates_df: &lt;description&gt;
    :type updates_df: DataFrame
    :param primary_key: &lt;description&gt;
    :type primary_key: str
    :param attr_col_names: &lt;description&gt;
    :type attr_col_names: List[str]

    :returns: &lt;description&gt;
    :rtype: None
    """
    return type_2_scd_generic_upsert(
        delta_table,
        updates_df,
        primary_key,
        attr_col_names,
        "is_current",
        "effective_time",
        "end_time",
    )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.validate_append" class="doc doc-heading">
<code class="highlight language-python">validate_append(delta_table, append_df, required_cols, optional_cols)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>delta_table</code></td>
          <td>
                <code><span title="delta.DeltaTable">DeltaTable</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>append_df</code></td>
          <td>
                <code><span title="pyspark.sql.dataframe.DataFrame">DataFrame</span></code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>required_cols</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>optional_cols</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when input arguments have a invalid type, are missing or are empty.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when required columns are missing in the provided delta table.</p></td>
        </tr>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when column in append dataframe is not part of the original delta table..</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def validate_append(
    delta_table: DeltaTable,
    append_df: DataFrame,
    required_cols: List[str],
    optional_cols: List[str],
) -&gt; None:
    """
    &lt;description&gt;

    :param delta_table: &lt;description&gt;
    :type delta_table: DeltaTable
    :param append_df: &lt;description&gt;
    :type append_df: DataFrame
    :param required_cols: &lt;description&gt;
    :type required_cols: List[str]
    :param optional_cols: &lt;description&gt;
    :type optional_cols: List[str]

    :raises TypeError: Raises type error when input arguments have a invalid type, are missing or are empty.
    :raises TypeError: Raises type error when required columns are missing in the provided delta table.
    :raises TypeError: Raises type error when column in append dataframe is not part of the original delta table..
    """
    if not isinstance(delta_table, DeltaTable):
        raise TypeError("An existing delta table must be specified.")

    if not isinstance(append_df, DataFrame):
        raise TypeError("You must provide a DataFrame that is to be appended.")

    append_data_columns = append_df.columns

    for required_column in required_cols:
        if required_column not in append_data_columns:
            raise TypeError(
                f"The base Delta table has these columns {append_data_columns!r}, but these columns are required {required_cols!r}"
            )

    table_columns = delta_table.toDF().columns

    for column in append_data_columns:
        if column not in table_columns and column not in optional_cols:
            raise TypeError(
                f"The column {column!r} is not part of the current Delta table."
                + " If you want to add the column to the table you must set the optional_cols parameter."
            )

    details = delta_table.detail().select("location").collect()[0]

    (
        append_df.write.format("delta")
        .mode("append")
        .option("mergeSchema", "true")
        .save(details["location"])
    )</code></pre>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="mack.with_md5_cols" class="doc doc-heading">
<code class="highlight language-python">with_md5_cols(df, cols, output_col_name=None)</code>

</h2>


  <div class="doc doc-contents ">
  
      <p><description></p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>df</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[<span title="delta.DeltaTable">DeltaTable</span>, <span title="pyspark.sql.dataframe.DataFrame">DataFrame</span>]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>cols</code></td>
          <td>
                <code><span title="typing.List">List</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>output_col_name</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[str]</code>
          </td>
          <td><p><description></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>DataFrame</code>
          </td>
          <td><p><description></p></td>
        </tr>
    </tbody>
  </table>

  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>TypeError</code>
          </td>
          <td><p>Raises type error when no composite key can be found.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>mack/__init__.py</code></summary>
        <pre class="highlight"><code class="language-python">def with_md5_cols(
    df: Union[DeltaTable, DataFrame],
    cols: List[str],
    output_col_name: Optional[str] = None,
) -&gt; DataFrame:
    """
    &lt;description&gt;

    :param df: &lt;description&gt;
    :type df: DeltaTable or DataFrame
    :param cols: &lt;description&gt;
    :type cols: List[str]
    :param output_col_name: &lt;description&gt;
    :type output_col_name: str, defaults to empty string.

    :raises TypeError: Raises type error when no composite key can be found.

    :returns: &lt;description&gt;
    :rtype: DataFrame
    """
    if output_col_name is None:
        output_col_name = "_".join(["md5"] + cols)
    if type(df) == DeltaTable:
        df = df.toDF()
    return df.withColumn(output_col_name, md5(concat_ws("||", *cols)))</code></pre>
      </details>
  </div>

</div>



  </div>

  </div>

</div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
